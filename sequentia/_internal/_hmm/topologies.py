# Copyright (c) 2019 Sequentia Developers.
# Distributed under the terms of the MIT License (see the LICENSE file).
# SPDX-License-Identifier: MIT
# This source code is part of the Sequentia project (https://github.com/eonu/sequentia).

from __future__ import annotations

import warnings

import numpy as np

from sequentia._internal._validation import FloatArray
from sequentia.enums import TopologyMode

__all__ = [
    "ErgodicTopology",
    "LeftRightTopology",
    "LinearTopology",
    "TOPOLOGY_MAP",
]


class BaseTopology:
    """Represents a topology for a HMM, imposing restrictions on the
    transition matrix and initial state distribution.

    Parameters
    ----------
    n_states: int
        Number of states in the HMM.

    random_state: numpy.random.RandomState
        A random state object for reproducible randomness.
    """

    mode: TopologyMode

    def __init__(
        self: BaseTopology,
        *,
        n_states: int,
        random_state: np.random.RandomState,
    ) -> BaseTopology:
        self.n_states = n_states
        self.random_state = random_state

    def uniform_start_probs(self: BaseTopology) -> FloatArray:
        """Set the initial state distribution as a discrete uniform
        distribution.

        Returns
        -------
        initial: :class:`numpy:numpy.ndarray` (float)
            The initial state distribution of shape `(n_states,)`.
        """
        return np.ones(self.n_states) / self.n_states

    def random_start_probs(self: BaseTopology) -> FloatArray:
        """Set the initial state distribution by randomly sampling
        probabilities generated by a Dirichlet distribution.

        Returns
        -------
        initial: :class:`numpy:numpy.ndarray` (float)
            The initial state distribution of shape `(n_states,)`.
        """
        return self.random_state.dirichlet(
            np.ones(self.n_states),
            size=1,
        ).flatten()

    def uniform_transition_probs(self: BaseTopology) -> FloatArray:
        """Set the transition matrix as uniform (equal probability of
        transitioning to all other possible states from each state)
        corresponding to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The uniform transition matrix of shape `(n_states, n_states)`.
        """
        raise NotImplementedError

    def random_transition_probs(self: BaseTopology) -> FloatArray:
        """Set the transition matrix as random (random probability of
        transitioning to all other possible states from each state) by
        sampling probabilitiesfrom a Dirichlet distribution - according
        to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The random transition matrix of shape `(n_states, n_states)`.
        """
        raise NotImplementedError

    def check_start_probs(self: BaseTopology, initial: FloatArray, /) -> None:
        """Validate an initial state distribution according to the
        topology's restrictions.

        Parameters
        ----------
        initial: numpy.ndarray (float)
            The initial state distribution to validate.
        """
        if not isinstance(initial, np.ndarray):
            msg = "Initial state distribution must be a numpy.ndarray"
            raise TypeError(msg)
        if initial.shape != (self.n_states,):
            msg = "Initial state distribution must be of shape (n_states,)"
            raise ValueError(msg)
        if not np.isclose(initial.sum(), 1):
            msg = "Initial state distribution must sum to one"
            raise ValueError(msg)
        return initial

    def check_transition_probs(
        self: BaseTopology, transitions: FloatArray, /
    ) -> FloatArray:
        """Validate a transition matrix according to the topology's
        restrictions.

        Parameters
        ----------
        transitions: numpy.ndarray (float)
            The transition matrix to validate.
        """
        if not isinstance(transitions, np.ndarray):
            msg = "Transition matrix must be a numpy.ndarray"
            raise TypeError(msg)
        if transitions.shape != (self.n_states, self.n_states):
            msg = "Transition matrix must be of shape (n_states, n_states)"
            raise ValueError(msg)
        if not np.allclose(transitions.sum(axis=1), np.ones(self.n_states)):
            msg = "Transition probabilities out of each state must sum to one"
            raise ValueError(msg)
        return transitions


class ErgodicTopology(BaseTopology):
    """Represents the topology for an ergodic HMM, imposing non-zero
    probabilities in the transition matrix.

    Parameters
    ----------
    n_states: int
        Number of states in the HMM.

    random_state: numpy.random.RandomState
        A random state object for reproducible randomness.
    """

    mode: TopologyMode = TopologyMode.ERGODIC

    def uniform_transition_probs(self: ErgodicTopology) -> FloatArray:
        """Set the transition matrix as uniform (equal probability of
        transitioning to all other possible states from each state)
        corresponding to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The uniform transition matrix of shape `(n_states, n_states)`.
        """
        return np.ones((self.n_states, self.n_states)) / self.n_states

    def random_transition_probs(self: ErgodicTopology) -> FloatArray:
        """Set the transition matrix as random (random probability of
        transitioning to all other possible states from each state) by
        sampling probabilities from a Dirichlet distribution - according
        to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The random transition matrix of shape `(n_states, n_states)`.
        """
        return self.random_state.dirichlet(
            np.ones(self.n_states),
            size=self.n_states,
        )

    def check_transition_probs(
        self: ErgodicTopology, transitions: FloatArray, /
    ) -> FloatArray:
        """Validate a transition matrix according to the topology's
        restrictions.

        Parameters
        ----------
        transitions: numpy.ndarray (float)
            The transition matrix to validate.
        """
        super().check_transition_probs(transitions)
        if not np.all(transitions > 0):
            msg = (
                "Zero probabilities in ergodic transition matrix - "
                "these transition probabilities will not be learned"
            )
            warnings.warn(msg, stacklevel=1)
        return transitions


class LeftRightTopology(BaseTopology):
    """Represents the topology for a left-right HMM, imposing an
    upper-triangular transition matrix.

    Parameters
    ----------
    n_states: int
        Number of states in the HMM.

    random_state: numpy.random.RandomState
        A random state object for reproducible randomness.
    """

    mode: TopologyMode = TopologyMode.LEFT_RIGHT

    def uniform_transition_probs(self: LeftRightTopology) -> FloatArray:
        """Set the transition matrix as uniform (equal probability of
        transitioning to all other possible states from each state)
        corresponding to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The uniform transition matrix of shape `(n_states, n_states)`.
        """
        upper_ones = np.triu(np.ones((self.n_states, self.n_states)))
        upper_divisors = np.triu(
            np.tile(np.arange(self.n_states, 0, -1), (self.n_states, 1)).T
        )
        lower_ones = np.tril(np.ones(self.n_states), k=-1)
        return upper_ones / (upper_divisors + lower_ones)

    def random_transition_probs(self: LeftRightTopology) -> FloatArray:
        """Set the transition matrix as random (random probability of
        transitioning to all other possible states from each state) by
        sampling probabilities from a Dirichlet distribution, according
        to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The random transition matrix of shape `(n_states, n_states)`.
        """
        transitions = np.zeros((self.n_states, self.n_states))
        for i, row in enumerate(transitions):
            row[i:] = self.random_state.dirichlet(np.ones(self.n_states - i))
        return transitions

    def check_transition_probs(
        self: LeftRightTopology, transitions: FloatArray, /
    ) -> FloatArray:
        """Validate a transition matrix according to the topology's
        restrictions.

        Parameters
        ----------
        transitions: numpy.ndarray (float)
            The transition matrix to validate.
        """
        super().check_transition_probs(transitions)
        if not np.allclose(transitions, np.triu(transitions)):
            msg = "Left-right transition matrix must be upper-triangular"
            raise ValueError(msg)
        return transitions


class LinearTopology(LeftRightTopology):
    """Represents the topology for a linear HMM.

    Parameters
    ----------
    n_states: int
        Number of states in the HMM.

    random_state: numpy.random.RandomState
        A random state object for reproducible randomness.
    """

    mode: TopologyMode = TopologyMode.LINEAR

    def uniform_transition_probs(self: LinearTopology) -> FloatArray:
        """Set the transition matrix as uniform (equal probability of
        transitioning to all other possible states from each state)
        corresponding to the topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The uniform transition matrix of shape `(n_states, n_states)`.
        """
        transitions = np.zeros((self.n_states, self.n_states))
        for i, row in enumerate(transitions):
            size = min(2, self.n_states - i)
            row[i : (i + size)] = np.ones(size) / size
        return transitions

    def random_transition_probs(self: LinearTopology) -> FloatArray:
        """Set the transition matrix as random (random probability of
        transitioning to all other possible states from each state) by
        sampling probabilities from a Dirichlet distribution, according to the
        topology.

        Returns
        -------
        transitions: :class:`numpy:numpy.ndarray` (float)
            The random transition matrix of shape `(n_states, n_states)`.
        """
        transitions = np.zeros((self.n_states, self.n_states))
        for i, row in enumerate(transitions):
            size = min(2, self.n_states - i)
            row[i : (i + size)] = self.random_state.dirichlet(np.ones(size))
        return transitions

    def check_transition_probs(
        self: LinearTopology, transitions: FloatArray, /
    ) -> FloatArray:
        """Validate a transition matrix according to the topology's
        restrictions.

        Parameters
        ----------
        transitions: numpy.ndarray (float)
            The transition matrix to validate.
        """
        super().check_transition_probs(transitions)
        diagonal = np.diag(np.diag(transitions))
        upper_diagonal = np.diag(np.diag(transitions, k=1), k=1)
        if not np.allclose(transitions, diagonal + upper_diagonal):
            msg = (
                "Linear transition matrix must only consist of "
                "a diagonal and upper diagonal"
            )
            raise ValueError(msg)
        return transitions


TOPOLOGY_MAP = {
    topology.mode: topology
    for topology in (ErgodicTopology, LeftRightTopology, LinearTopology)
}
