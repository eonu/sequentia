# Copyright (c) 2019 Sequentia Developers.
# Distributed under the terms of the MIT License (see the LICENSE file).
# SPDX-License-Identifier: MIT
# This source code is part of the Sequentia project (https://github.com/eonu/sequentia).

"""A hidden Markov model with univariate categorical emissions."""

from __future__ import annotations

import typing as t

import hmmlearn.hmm
import numpy as np
import pydantic as pyd

from sequentia import enums
from sequentia._internal import _validation
from sequentia._internal._typing import FloatArray
from sequentia.models.hmm.variants.base import BaseHMM

__all__ = ["CategoricalHMM"]


class CategoricalHMM(BaseHMM):
    """A hidden Markov model with univariate categorical emissions.

    Examples
    --------
    Using a :class:`.CategoricalHMM` to learn how to recognize DNA sequences
    from the synthetase gene family.

    See :func:`.load_gene_families` for more information on the sample
    dataset used in this example.

    ::

        import numpy as np
        from sequentia.datasets import load_gene_families
        from sequentia.models.hmm import CategoricalHMM

        # Seed for reproducible pseudo-randomness
        random_state = np.random.RandomState(1)

        # Fetch DNA sequences for the synthetase gene family (no. 4)
        data, enc = load_gene_families(families=[4])
        train_data, test_data = data.split(test_size=0.2, random_state=random_state)

        # Create and train a CategoricalHMM to recognize the synthetase DNA sequences
        model = CategoricalHMM(random_state=random_state)
        model.fit(train_data.X, lengths=train_data.lengths)

        # Calculate the log-likelihood of the first test sample being generated by this model
        x, y = test_data[0]
        model.score(x)
    """  # noqa: E501

    _DTYPE: type = np.int8
    _UNIVARIATE: bool = True

    @pyd.validate_call(config=dict(arbitrary_types_allowed=True))
    def __init__(
        self: pyd.SkipValidation,
        *,
        n_states: pyd.PositiveInt = 5,
        topology: enums.TopologyMode | None = enums.TopologyMode.LEFT_RIGHT,
        random_state: pyd.NonNegativeInt | np.random.RandomState | None = None,
        hmmlearn_kwargs: dict[str, t.Any] | None = None,
    ) -> pyd.SkipValidation:
        """Initializes the :class:`.CategoricalHMM`.

        Parameters
        ----------
        self: CategoricalHMM

        n_states:
            Number of states in the Markov chain.

        topology:
            Transition topology of the Markov chain — see :ref:`topologies`.

            If ``None``, behaves the same as ``'ergodic'`` but with
            `hmmlearn <https://hmmlearn.readthedocs.io/en/latest/>`__
            initialization.

        random_state:
            Seed or :class:`numpy:numpy.random.RandomState` object for
            reproducible pseudo-randomness.

        hmmlearn_kwargs:
            Additional key-word arguments provided to the
            `hmmlearn <https://hmmlearn.readthedocs.io/en/latest/>`__ HMM
            constructor.

        Returns
        -------
        CategoricalHMM
        """
        super().__init__(
            n_states=n_states,
            topology=topology,
            random_state=random_state,
            hmmlearn_kwargs=hmmlearn_kwargs,
        )

    @property
    @_validation.requires_fit
    def n_params(self: CategoricalHMM) -> int:
        """Number of trainable parameters — requires :func:`fit`."""
        n_params = super().n_params
        if "e" not in self._skip_params:
            n_params += self.model.emissionprob_.size
        return n_params

    def set_state_emission_probs(
        self: CategoricalHMM,
        probs: FloatArray,
        /,
    ) -> None:
        """Set the state emission distribution of the HMM's emission model.

        If this method is **not** called, emission probabilities will be
        initialized by
        `hmmlearn <https://hmmlearn.readthedocs.io/en/latest/>`__.

        Parameters
        ----------
        self: CategoricalHMM

        probs:
            Array of emission probabilities.

        Notes
        -----
        If used, this method should normally be called before :func:`fit`.
        """
        self._emissionprob = np.array(probs, dtype=np.float64)
        self._skip_init_params |= set("e")

    def freeze(self: CategoricalHMM, params: str | None = None, /) -> None:
        """Freeze the trainable parameters of the HMM,
        preventing them from being updated during the Baum—Welch algorithm.

        Parameters
        ----------
        self: CategoricalHMM

        params:
            A string specifying which parameters to freeze.
            Can contain a combination of:

            - ``'s'`` for initial state probabilities,
            - ``'t'`` for transition probabilities,
            - ``'e'`` for emission probailities.

        Notes
        -----
        If used, this method should normally be called before :func:`fit`.

        See Also
        --------
        unfreeze:
            Unfreeze the trainable parameters of the HMM,
            allowing them to be updated during the Baum—Welch algorithm.
        """
        super().freeze(params)

    def unfreeze(self: CategoricalHMM, params: str | None = None, /) -> None:
        """Unfreeze the trainable parameters of the HMM,
        allowing them to be updated during the Baum—Welch algorithm.

        Parameters
        ----------
        self: CategoricalHMM

        params:
            A string specifying which parameters to unfreeze.
            Can contain a combination of:

            - ``'s'`` for initial state probabilities,
            - ``'t'`` for transition probabilities,
            - ``'e'`` for emission probailities.

        See Also
        --------
        freeze:
            Freeze the trainable parameters of the HMM,
            preventing them from being updated during the Baum—Welch
            algorithm.
        """
        super().unfreeze(params)

    def _init_hmm(
        self: CategoricalHMM,
        **kwargs: t.Any,
    ) -> hmmlearn.hmm.CategoricalHMM:
        """Initialize the hmmlearn model."""
        return hmmlearn.hmm.CategoricalHMM(
            n_components=self.n_states,
            random_state=self.random_state_,
            **kwargs,
        )

    @staticmethod
    def _hmmlearn_kwargs_defaults() -> dict[str, t.Any]:
        """Default values for hmmlearn key-word arguments."""
        return {"init_params": "ste", "params": "ste"}

    @staticmethod
    def _hmmlearn_params() -> list[str]:
        """Names of trainable hmmlearn parameters."""
        return [*BaseHMM._hmmlearn_params(), "emissionprob"]  # noqa: SLF001
